# Sklon
Бэкенд взаимодействия с мобильныим и веб клиентом
## Структура проекта:
```text
1.        .-----------------------< Core
          |                           |
2.        |-----------------------< Jooq
          |                         / | \
3.        |  BusinessModule1 <-x-> BusinessModule2 <-x-> etc...
          |                         \ | /
4.        `---> Infrastructure ----> Web
        
```
### Назначение модулей:
* **Core:** модуль содержащий общий набор вспомогательных классов, общих моделей, существующих вне конкретного
  бизнес-контекста, общих инфраструктурных интерфейсов существующих вне бизнес-контекста.   
  К общим наборам моделей можно отнести такие модели как: валюта (`Currency`), денежная сумма (`MoneyAmount`), и др.  
  К общим инфраструктурным интерфейсам можно отнести такие как: интерфейс работы с файловым хранилищем (`FileService`),
  интерфейс работы с уведомлениями (`NotificationService`), и др.
* **Jooq:** модуль в который вынесен шаг по генерации jooq'ом java-классов для взаимодействия с БД (Таблицы, Вью, ХП,
  и др.). В отдельный модуль этот шаг вынесен в качестве оптимизации, чтобы не множить накладные расходы по генерации по
  количеству модулей. Также в этом модуле содержится код специфичный для Jooq (`ConditionBuilder` и др.)
* **Infrastructure:** модуль реализующий инфраструктурные интерфейсы модуля `Core`. Он не содержит, и не должен
  содержать, никакой бизнес-специфики. От данного модуля не должны зависеть бизнес-модули третьего уровня.
* **BusinessModuleN:** модули третьего уровня в которых содержится бизнес-специфичная реализация. Каждый из модулей
  этого уровня представляет собой отдельный бизнес-контекст (`Bounded Context`). Каждый модуль изолирует какую-то
  определенную бизнес-задачу. В пример можно привести такие задачи как: подача заявки на полет (`order-request`),
  оформление страхового полиса (`insurance-purchase`), и т.д.  
  Модули этого уровня **не должны** общаться друг с другом **напрямую** (модули этого уровня **не должны** зависеть от
  соседних модулей этого уровня напрямую, т.е. иметь `maven` зависимость в виде соседа). Тем не менее, разделенные
  бизнес-контексты **имеют необходимость общаться**. Осуществлять их взаимодействие предлагается через:
    - **Абстракцию:** модуль клиент (модуль, которому требуется обратиться к соседу), объявляет некий интерфейс и
      набор `DTO`. Модуль `Web` реализует этот интерфейс и обращается к целевому модулю также используя некий интерфейс.
      Модуль `Web` осуществляет преобразование запроса и ответа от модуля клиента. Таким образом модуль `Web` в данном
      случае играет роль `Anti Corruption Layer (ACL)` за счет чего снижается связанность модулей. [Детали по применению](#правила-реализации-портов-для-общения-между-бизнес-модулями-третьего-уровня)
    - **События:** в случае, если необходима еще более слабая связь, или модуль имеет потребность передать команду или
      сообщение не одному, а нескольким или всем соседним модулям, то для этого предлагается использовать события. Поскольку
      в текущем виде проект по прежнему представляет собой монолит, чтобы избежать лишних издержек, предлагается
      использовать спринговый EventBus. Реализация общения между модулем источником события и EventBus предлагается
      осуществлять также с помощью объявления некого интерфейса в модуле источнике и последующей его реализации в модуле
      `Web`. Такой вариант в дальнейшем должен упростить переход на выделенный брокер, которым сможет выступить `RabbitMq`
      или аналоги.
* **Web:** модуль зависящий от всех остальных. Из него собирается конечный артефакт приложения (spring boot executable).
  Также модуль играет роль `Anti Corruption Layer (ACL)` для общения модулей третьего уровня между собой. Также модуль
  содержит общие для приложения бины конфигурации спринга.

Основой целью такого разделения является подготовка к потенциальному переходу на микросервисную архитектуру и снижение
связанности бизнес-направлений проекта, что должно также позволить более уверенно и независимо развивать каждое из них.

Более подробную информацию о назначении, задачах и т.д. следует искать в документации к конкретному модулю.

## Общие правила и соглашения разработки в проекте
### Рекомендуемая структура пакетов для бизнесовых модулей
```text
<root.package>\
  |- nsi\         - Все справочники модуля, поскольку все они не имеют какого-то бизнесового
  |  |- dict1\      поведения, все их слои описаны в этом пакете.
  |  |- dict2\
  |  ...
  |
  |- domain\      - Код относящийся к предметной области модуля: модели, value object, dao, сервисы. 
  |  |- entity1\    Сервис можно положить в этот пакет если он занимается не просто оркестрацией вызовов, а содержит 
  |  |- entity2\    бизнесовую логику. К примеру занимается принятием решений которые можно отнести к бизнес-правилам.
  |  ...          
  |
  |- usecase\     - Реализация конкретных сценариев реализуемых модулем. К сценариям относятся вызовы REST Api, вызовы 
  |  |- entitylist\ из портов и др. К примеру списков или карточек на фронт предлагается делать прямо в usecase обращаясь 
  |  |- entitycard\ напрямую к БД.
  |  |- entityoperation\
  |  ...
  |
  |- exception\   - Исключения модуля
  |- integration\ - Код по интеграции с внешними сервисами
  |- ports\       - Порты ввода и вывода вызовов в (из) модуля  
```

### На каждый бизнесс-модуль желательно иметь один единственный префикс
Т.е. если модуль `order-request` то и путь у всех его методов будет иметь префикс `/api/order-request/**`. Но возможны исключения, к примеру интеграционные методы - `/api/integration/order-request/**`.

### Пути к сущностям указываем в единственном числе. Примеры:
```text
GET    /api/company-profile/employee       - Получить список объектов
POST   /api/company-profile/employee       - Добавить объект
PUT    /api/company-profile/employee/{id}  - Изменить объект
DELETE /api/company-profile/employee/{id}  - Удалить объект
```
### Правила реализации портов для общения между бизнес модулями третьего уровня
1. Интерфейсы, через которые общаются бизнес модули третьего уровня называем Портами:
    - `*InputPort` - интерфейс который предоставляет модуль для других модулей. Его реализует модуль объявляющий данный
      интерфейс.
    - `*OutputPort` - интерфейс через который модуль его объявивший общается с другими модулями. Его реализует модуль
      `-web`.
2. Реализация `*OutputPort`-а в модуле `-web` называем адаптером - `*OutputPortAdapter` (т.к. он адаптирует
   `OutputPort` к интерфейсу (интерфейсам) `*InputPort`-а другого модуля).
3. Все порты внутри бизнес-модулей третьего уровня располагаем в пакетах `ru.sklon.business.<module>.ports.in\out`
4. Порты следует класть не в корень пакета `ru.sklon.business.<module>.ports.in\out`, а в подпакет с соответствующим
   назначению именем (прим. `ru.sklon.business.<module>.ports.in\out.employee`), чтобы при необходимости можно было
   разместить в нем код с уровнем доступа `package`.
5. Класс Адаптера (`*OutputPortAdapter`) располагаюем в модуле `-web` внутри пакета соответствующего пакету
   адаптируемого `*OutputPort`-а. (прим. `ru.sklon.business.employeeinvitation.ports.out.employee`).
